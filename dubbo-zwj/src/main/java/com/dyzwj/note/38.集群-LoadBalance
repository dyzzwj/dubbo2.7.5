介绍dubbo中集群的负载均衡，介绍dubbo-cluster下loadBalance包的源码

Dubbo 提供了4种负载均衡实现：

1、RandomLoadBalance：基于权重随机算法
2、LeastActiveLoadBalance：基于最少活跃调用数算法
3、ConsistentHashLoadBalance：基于 hash 一致性
4、RoundRobinLoadBalance：基于加权轮询算法

一、AbstractLoadBalance
该类实现了LoadBalance接口，是负载均衡的抽象类，提供了权重计算的功能。

二、RandomLoadBalance
该类是基于权重随机算法的负载均衡实现类，我们先来讲讲原理，比如我有有一组服务器 servers = [A, B, C]，
他们他们对应的权重为 weights = [6, 3, 1]，权重总和为10，现在把这些权重值平铺在一维坐标值上，分别出现三个区域，
A区域为[0,6)，B区域为[6,9)，C区域为[9,10)，然后产生一个[0, 10)的随机数，看该数字落在哪个区间内，就用哪台服务器，这样权重越大的，被击中的概率就越大。

三、LeastActiveLoadBalance
该负载均衡策略基于最少活跃调用数算法，某个服务活跃调用数越小，表明该服务提供者效率越高，也就表明单位时间内能够处理的请求更多。
此时应该选择该类服务器。实现很简单，就是每一个服务都有一个活跃数active来记录该服务的活跃值，每收到一个请求，该active就会加1，，没完成一个请求，active就会减1。
在服务运行一段时间后，性能好的服务提供者处理请求的速度更快，因此活跃数下降的也越快，此时这样的服务提供者能够优先获取到新的服务请求。
除了最小活跃数，还引入了权重值，也就是当活跃数一样的时候，选择利用权重法来进行选择，如果权重也一样，那么随机选择一个。

四、ConsistentHashLoadBalance
该类是负载均衡基于 hash 一致性的逻辑实现。一致性哈希算法由麻省理工学院的 Karger 及其合作者于1997年提供出的，一开始被大量运用于缓存系统的负载均衡。
它的工作原理是这样的：首先根据 ip 或其他的信息为缓存节点生成一个 hash，在dubbo中使用参数进行计算hash。并将这个 hash 投射到 [0, 2的32次方 - 1] 的圆环上，
当有查询或写入请求时，则生成一个 hash 值。然后查找第一个大于或等于该 hash 值的缓存节点，并到这个节点中查询或写入缓存项。如果当前节点挂了，则在下一次查询或写入缓存时，
为缓存项查找另一个大于其 hash 值的缓存节点即可。
每个缓存节点在圆环上占据一个位置。如果缓存项的 key 的 hash 值小于缓存节点 hash 值，则到该缓存节点中存储或读取缓存项，这里有两个概念不要弄混，
缓存节点就好比dubbo中的服务提供者，会有很多的服务提供者，而缓存项就好比是服务引用的消费者。比如下面绿色点对应的缓存项也就是服务消费者将会被存储到 cache-2 节点中。
由于 cache-3 挂了，原本应该存到该节点中的缓存项也就是服务消费者最终会存储到 cache-4 节点中，也就是调用cache-4 这个服务提供者
但是在hash一致性算法并不能够保证hash算法的平衡性，就拿上面的例子来看，cache-3挂掉了，那该节点下的所有缓存项都要存储到 cache-4 节点中，这就导致hash值低的一直往高的存储，会面临一个不平衡的现象，
可以看到最后会变成类似不平衡的现象，那我们应该怎么避免这样的事情，做到平衡性，那就需要引入虚拟节点，虚拟节点是实际节点在 hash 空间的复制品，“虚拟节点”在 hash 空间中以hash值排列
可以看到各个节点都被均匀分布在圆环上，而某一个服务提供者居然有多个节点存在，分别跟其他节点交错排列，这样做的目的就是避免数据倾斜问题，也就是由于节点不够分散，导致大量请求落到了同一个节点上，而其他节点只会接收到了少量请求的情况。类似第二张图的情况。


五、RoundRobinLoadBalance
该类是负载均衡基于加权轮询算法的实现。那么什么是加权轮询，轮询很好理解，比如我第一个请求分配给A服务器，第二个请求分配给B服务器，第三个请求分配给C服务器，第四个请求又分配给A服务器，这就是轮询，
但是这只适合每台服务器性能相近的情况，这种是一种非常理想的情况，那更多的是每台服务器的性能都会有所差异，这个时候性能差的服务器被分到等额的请求，就会需要承受压力大宕机的情况，
这个时候我们需要对轮询加权，我举个例子，服务器 A、B、C 权重比为 6:3:1，那么在10次请求中，服务器 A 将收到其中的6次请求，服务器 B 会收到其中的3次请求，服务器 C 则收到其中的1次请求，
也就是说每台服务器能够收到的请求归结于它的权重





















